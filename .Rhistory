maindat <- mvrnorm(Nm,mu=c(2,3,1),Sigma=rbind(c(2,1,1),c(1,2,1),c(1,1,2)))
auxdat  <- mvrnorm(Na,mu=c(2,3,1),Sigma=rbind(c(2,1,1),c(1,2,1),c(1,1,2)))
maindat <- as.data.frame(maindat)
auxdat <- as.data.frame(auxdat)
colnames(maindat) <- c("x1","x2","x3")
colnames(auxdat) <- c("x1","x2","x3")
truebeta <- matrix(c(2,1,3,2),ncol=1)
maindat$y <- as.matrix(cbind(rep(1,Nm),maindat[,c("x1","x2","x3")]))%*%truebeta
# main data misses one omitted variable "x1"
maindat <- maindat[,c("x2","x3","y")]
# load libraries
library(stats)
library(utils)
library(np)
library(pracma)
#############
# prepare data in a right form
#############
# number of observations
Nm <- dim(maindat)[1]
Na <- dim(auxdat)[1]
# add 1 vector
comvar <- c(comvar,"con")
maindat$con <- rep(1,Nm)
auxdat$con <- rep(1,Na)
# leave only necessary variables and make the order of variables consistent
maindat <- maindat[,c(depvar,comvar)]
auxdat <- auxdat[,c(ovar,comvar)]
# number of regressors in a regrssion model
nr <- length(comvar)+length(ovar)
#############
comvar2 <- comvar[comvar!="con"]
# estimate f(depvar | comvar) nonparametrically
# bandwidth selection
bws1 <- npcdistbw(ydat=maindat[,depvar],xdat=maindat[,comvar2])
Fyz  <- npcdist(bws1)$condist ### Fyz$condist saves the predicted cdf values
bws2 <- npcdistbw(ydat=auxdat[,ovar],xdat=auxdat[,comvar2])
# compute matching function mu(depvar) = ovar| depvar, comvar
mu_y <- function(xx,ccdf,maximize){
if (maximize==1){
# find matching ovar to maximize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=ccdf,exdat=xx)$quantile
} else {
# find matching ovar to minimize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=(1-ccdf),exdat=xx)$quantile
}
return(ovar1)
}
ovar_m_l <- rep(NA,Nm)
ovar_m_u <- rep(NA,Nm)
maindat[,comvar2]
i=1
eexdat <- data.frame(matrix(maindat[i,comvar2],nrow=1))
colnames(eexdat) <- comvar2 ### make the data frame similar to txdat
maindat[i,comvar2]
eexdat <- data.frame(matrix(maindat[i,comvar2],nrow=1))
colnames(eexdat) <- comvar2 ### make the data frame similar to txdat
eexdat
ovar_m_l[i]     <- mu_y(xx=eexdat,ccdf=Fyz[i],maximize=0)
class(maindat[i,comvar2])
comvar2
class(maindat[i,"x2"])
class(maindat[i,"x3"])
class(auxdat[,"x2"])
class(auxdat[,"x3"])
rownames(maindat[i,comvar2])
rownames(auxdat[,comvar2])
colnames(auxdat[,comvar2])
colnames(maindat[,comvar2])
# simpler replication
mydat <- data.frame(y=rnorm(10),x1=rnorm(10),x2=rnorm(10))
bw <- npcdistbw(ydat=mydat[,"y"],xdat=mydat[,c("x1","x2")])
xx <- data.frame(matrix(c(1,3),nrow=1))
colnames(xx) <- c("x1","x2") ### make the data frame similar to txdat
mu_y <- function(xx,ccdf,maximize){
if (maximize==1){
# find matching ovar to maximize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=ccdf,exdat=xx)$quantile
} else {
# find matching ovar to minimize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=(1-ccdf),exdat=xx)$quantile
}
return(ovar1)
}
ovar1  <- mu_y(xx=xx,ccdf=0.5,maximize=1)$quantile
# simpler replication
mydat <- data.frame(y=rnorm(10),x1=rnorm(10),x2=rnorm(10))
bw <- npcdistbw(ydat=mydat[,"y"],xdat=mydat[,c("x1","x2")])
xx <- data.frame(matrix(c(1,3),nrow=1))
colnames(xx) <- c("x1","x2") ### make the data frame similar to txdat
mu_y <- function(xx,ccdf,maximize){
if (maximize==1){
# find matching ovar to maximize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=ccdf,exdat=xx)$quantile
} else {
# find matching ovar to minimize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=(1-ccdf),exdat=xx)
}
return(ovar1)
}
ovar1  <- mu_y(xx=xx,ccdf=0.5,maximize=1)$quantile
# simpler replication
mydat <- data.frame(y=rnorm(10),x1=rnorm(10),x2=rnorm(10))
bw <- npcdistbw(ydat=mydat[,"y"],xdat=mydat[,c("x1","x2")])
xx <- data.frame(matrix(c(1,3),nrow=1))
colnames(xx) <- c("x1","x2") ### make the data frame similar to txdat
mu_y <- function(xx,ccdf,maximize){
if (maximize==1){
# find matching ovar to maximize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=ccdf,exdat=xx)
} else {
# find matching ovar to minimize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=(1-ccdf),exdat=xx)
}
return(ovar1)
}
ovar1  <- mu_y(xx=xx,ccdf=0.5,maximize=1)$quantile
ovar1
#### Monte Carlo simulation
Nm <- 10
Na <- 10
# same DGP in maindat and auxdat
library(MASS)
library(dplyr)
maindat <- mvrnorm(Nm,mu=c(2,3,1),Sigma=rbind(c(2,1,1),c(1,2,1),c(1,1,2)))
auxdat  <- mvrnorm(Na,mu=c(2,3,1),Sigma=rbind(c(2,1,1),c(1,2,1),c(1,1,2)))
maindat <- as.data.frame(maindat)
auxdat <- as.data.frame(auxdat)
colnames(maindat) <- c("x1","x2","x3")
colnames(auxdat) <- c("x1","x2","x3")
truebeta <- matrix(c(2,1,3,2),ncol=1)
maindat$y <- as.matrix(cbind(rep(1,Nm),maindat[,c("x1","x2","x3")]))%*%truebeta
# main data misses one omitted variable "x1"
maindat <- maindat[,c("x2","x3","y")]
# load libraries
library(stats)
library(utils)
library(np)
library(pracma)
#############
# prepare data in a right form
#############
# number of observations
Nm <- dim(maindat)[1]
Na <- dim(auxdat)[1]
# add 1 vector
comvar <- c(comvar,"con")
maindat$con <- rep(1,Nm)
auxdat$con <- rep(1,Na)
# leave only necessary variables and make the order of variables consistent
maindat <- maindat[,c(depvar,comvar)]
auxdat <- auxdat[,c(ovar,comvar)]
# number of regressors in a regrssion model
nr <- length(comvar)+length(ovar)
comvar2 <- comvar[comvar!="con"]
# estimate f(depvar | comvar) nonparametrically
# bandwidth selection
bws1 <- npcdistbw(ydat=maindat[,depvar],xdat=maindat[,comvar2])
Fyz  <- npcdist(bws1)$condist ### Fyz$condist saves the predicted cdf values
bws2 <- npcdistbw(ydat=auxdat[,ovar],xdat=auxdat[,comvar2])
# compute matching function mu(depvar) = ovar| depvar, comvar
mu_y <- function(xx,ccdf,maximize){
if (maximize==1){
# find matching ovar to maximize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=ccdf,exdat=xx)$quantile
} else {
# find matching ovar to minimize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=(1-ccdf),exdat=xx)$quantile
}
return(ovar1)
}
ovar_m_l <- rep(NA,Nm)
ovar_m_u <- rep(NA,Nm)
i=1
eexdat <- data.frame(maindat[i,comvar2])
colnames(eexdat) <- comvar2 ### make the data frame similar to txdat
ovar_m_l[i]     <- mu_y(xx=eexdat,ccdf=Fyz[i],maximize=0)
ovar_m_l[i]
bndovb <- function(maindat,auxdat,depvar,ovar,comvar,method=1,seed=210316){
# set seed
set.seed(seed)
# load libraries
library(stats)
library(utils)
library(np)
library(pracma)
#############
# check if inputs are there in a correct form
#############
if (!is.matrix(maindat) & !is.data.frame(maindat)){
stop("please provide main data in either matrix or data frame format.")
}
if (!is.matrix(auxdat) & !is.data.frame(auxdat)){
stop("please provide auxiliary data in either matrix or data frame format.")
}
# check if column names of auxiliary data exists
if (is.null(colnames(auxdat))){
stop("column names of auxiliary data do not exist.")
}
# check if column names of main data exists
if (is.null(colnames(maindat))){
stop("column names of main data do not exist.")
}
# check if auxiliary dataset includes every independent regressor
if ((sum(comvar%in%colnames(auxdat))<length(comvar)) | !(ovar%in%colnames(auxdat)) ){
stop("auxiliary dataset does not contain every right-hand side regressor.")
}
# check if main dataset includes every independent regressor
if (sum(comvar%in%colnames(maindat))<length(comvar)){
stop("main dataset does not contain every common right-hand side regressor.")
}
# check if main dataset includes dependent variable
if (!(depvar%in%colnames(maindat))){
stop("main dataset does not include the dependent variable.")
}
# check if method is specified correctly
if (!(method%in%c(1,2))){
stop("Incorrect method was specified. Method should be either 1 or 2.")
}
#############
# prepare data in a right form
#############
# number of observations
Nm <- dim(maindat)[1]
Na <- dim(auxdat)[1]
# add 1 vector
comvar <- c(comvar,"con")
maindat$con <- rep(1,Nm)
auxdat$con <- rep(1,Na)
# leave only necessary variables and make the order of variables consistent
maindat <- maindat[,c(depvar,comvar)]
auxdat <- auxdat[,c(ovar,comvar)]
# number of regressors in a regrssion model
nr <- length(comvar)+length(ovar)
#############
# estimate CDF and Quantile function
#############
if (method==1){
# estimate N(depvar | comvar)
f1 <- paste0(depvar,"~ 0 +",comvar[1])
if (length(comvar)>1){
for (k in 2:length(comvar)){
f1 <- paste0(f1,"+",comvar[k])
}
}
oout1 <- lm(formula=f1,data=maindat) ## regression without intercept because of "con" in "comvar"
Fypar <- matrix(oout1$coefficients,ncol=1)
yhat  <- as.matrix(maindat[,comvar])%*%Fypar
ysd   <- sd(oout1$residuals,na.rm=TRUE)
# estimate N(ovar | comvar)
f2 <- paste0(ovar,"~ 0 +",comvar[1])
if (length(comvar)>1){
for (k in 2:length(comvar)){
f2 <- paste0(f2,"+",comvar[k])
}
}
oout2 <- lm(formula=f2,data=auxdat) ## regression without intercept because of "con" in "comvar"
Fopar <- matrix(oout2$coefficients,ncol=1)
# prediction in main data, not auxiliary data
ohat  <- as.matrix(maindat[,comvar])%*%Fopar
osd   <- sd(oout2$residuals,na.rm=TRUE)
#############
# compute bounds of E[(depvar)*(omitted variable)]
#############
ovar_m_l <- rep(NA,Nm)
ovar_m_u <- rep(NA,Nm)
for (k in 1:Nm){
ovar_m_u[k] <- qnorm(p=   pnorm(q=maindat[k,depvar],mean=yhat[k],sd=ysd) ,mean=ohat[k],sd=osd)
ovar_m_l[k] <- qnorm(p=(1-pnorm(q=maindat[k,depvar],mean=yhat[k],sd=ysd)),mean=ohat[k],sd=osd)
}
} else if (method==2){
comvar2 <- comvar[comvar!="con"]
# estimate f(depvar | comvar) nonparametrically
# bandwidth selection
bws1 <- npcdistbw(ydat=maindat[,depvar],xdat=maindat[,comvar2])
Fyz  <- npcdist(bws1)$condist ### Fyz$condist saves the predicted cdf values
bws2 <- npcdistbw(ydat=auxdat[,ovar],xdat=auxdat[,comvar2])
# compute matching function mu(depvar) = ovar| depvar, comvar
mu_y <- function(xx,ccdf,maximize){
if (maximize==1){
# find matching ovar to maximize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=ccdf,exdat=xx)$quantile
} else {
# find matching ovar to minimize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=(1-ccdf),exdat=xx)$quantile
}
return(ovar1)
}
ovar_m_l <- rep(NA,Nm)
ovar_m_u <- rep(NA,Nm)
for(i in 1:Nm){
eexdat <- data.frame(maindat[i,comvar2])
colnames(eexdat) <- comvar2 ### make the data frame similar to txdat
ovar_m_l[i]     <- mu_y(xx=eexdat,ccdf=Fyz[i],maximize=0)
ovar_m_u[i]     <- mu_y(xx=eexdat,ccdf=Fyz[i],maximize=1)
rm(eexdat)
}
} else {
stop("Method should be either 1 or 2.")
}
#############
# compute lower bound and upper bound
#############
mu_l <- mean(maindat[,depvar]*ovar_m_l,na.rm=TRUE)
mu_u <- mean(maindat[,depvar]*ovar_m_u,na.rm=TRUE)
hat_beta_l <- rep(NA,nr)
hat_beta_u <- rep(NA,nr)
# submatrices
A1 <- (t(as.matrix(auxdat[,ovar]))%*%as.matrix(auxdat[,ovar]))/Na
A2 <- (t(as.matrix(auxdat[,ovar]))%*%as.matrix(auxdat[,comvar]))/Na
C  <- as.matrix(rbind(maindat[,comvar],auxdat[,comvar]))
A3 <- (t(C)%*%C)/(Na+Nm)
XX <- as.matrix(rbind(cbind(A1,A2),cbind(t(A2),A3)))
# OLS formula
B <- (t(as.matrix(maindat[,depvar]))%*%as.matrix(maindat[,comvar]))/Nm
B_l <- matrix(c(mu_l,B),ncol=1)
B_u <- matrix(c(mu_u,B),ncol=1)
hat_beta_l <- matrix(pmin(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
hat_beta_u <- matrix(pmax(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
colnames(hat_beta_l) <- c(ovar,comvar)
colnames(hat_beta_u) <- c(ovar,comvar)
# change the order of OLS coefficients
comvar2 <- comvar[comvar!="con"]
hat_beta_l <- c(hat_beta_l[,"con"],hat_beta_l[,ovar],hat_beta_l[,comvar2])
hat_beta_u <- c(hat_beta_u[,"con"],hat_beta_u[,ovar],hat_beta_u[,comvar2])
return(list(hat_beta_l=hat_beta_l,hat_beta_u=hat_beta_u))
}
#### Monte Carlo simulation
Nm <- 10
Na <- 10
# same DGP in maindat and auxdat
library(MASS)
library(dplyr)
maindat <- mvrnorm(Nm,mu=c(2,3,1),Sigma=rbind(c(2,1,1),c(1,2,1),c(1,1,2)))
auxdat  <- mvrnorm(Na,mu=c(2,3,1),Sigma=rbind(c(2,1,1),c(1,2,1),c(1,1,2)))
maindat <- as.data.frame(maindat)
auxdat <- as.data.frame(auxdat)
colnames(maindat) <- c("x1","x2","x3")
colnames(auxdat) <- c("x1","x2","x3")
truebeta <- matrix(c(2,1,3,2),ncol=1)
maindat$y <- as.matrix(cbind(rep(1,Nm),maindat[,c("x1","x2","x3")]))%*%truebeta
# main data misses one omitted variable "x1"
maindat <- maindat[,c("x2","x3","y")]
oout <- bndovb(maindat=maindat,auxdat=auxdat,depvar="y",ovar="x1",comvar=c("x2","x3"),method=2)
oout
truebeta
bndovb <- function(maindat,auxdat,depvar,ovar,comvar,method=1,seed=210316){
# set seed
set.seed(seed)
# load libraries
library(stats)
library(utils)
library(np)
library(pracma)
#############
# check if inputs are there in a correct form
#############
if (!is.matrix(maindat) & !is.data.frame(maindat)){
stop("please provide main data in either matrix or data frame format.")
}
if (!is.matrix(auxdat) & !is.data.frame(auxdat)){
stop("please provide auxiliary data in either matrix or data frame format.")
}
# check if column names of auxiliary data exists
if (is.null(colnames(auxdat))){
stop("column names of auxiliary data do not exist.")
}
# check if column names of main data exists
if (is.null(colnames(maindat))){
stop("column names of main data do not exist.")
}
# check if auxiliary dataset includes every independent regressor
if ((sum(comvar%in%colnames(auxdat))<length(comvar)) | !(ovar%in%colnames(auxdat)) ){
stop("auxiliary dataset does not contain every right-hand side regressor.")
}
# check if main dataset includes every independent regressor
if (sum(comvar%in%colnames(maindat))<length(comvar)){
stop("main dataset does not contain every common right-hand side regressor.")
}
# check if main dataset includes dependent variable
if (!(depvar%in%colnames(maindat))){
stop("main dataset does not include the dependent variable.")
}
# check if method is specified correctly
if (!(method%in%c(1,2))){
stop("Incorrect method was specified. Method should be either 1 or 2.")
}
#############
# prepare data in a right form
#############
# number of observations
Nm <- dim(maindat)[1]
Na <- dim(auxdat)[1]
# add 1 vector
comvar <- c(comvar,"con")
maindat$con <- rep(1,Nm)
auxdat$con <- rep(1,Na)
# leave only necessary variables and make the order of variables consistent
maindat <- maindat[,c(depvar,comvar)]
auxdat <- auxdat[,c(ovar,comvar)]
# number of regressors in a regrssion model
nr <- length(comvar)+length(ovar)
#############
# estimate CDF and Quantile function
#############
if (method==1){
# estimate N(depvar | comvar)
f1 <- paste0(depvar,"~ 0 +",comvar[1])
if (length(comvar)>1){
for (k in 2:length(comvar)){
f1 <- paste0(f1,"+",comvar[k])
}
}
oout1 <- lm(formula=f1,data=maindat) ## regression without intercept because of "con" in "comvar"
Fypar <- matrix(oout1$coefficients,ncol=1)
yhat  <- as.matrix(maindat[,comvar])%*%Fypar
ysd   <- sd(oout1$residuals,na.rm=TRUE)
# estimate N(ovar | comvar)
f2 <- paste0(ovar,"~ 0 +",comvar[1])
if (length(comvar)>1){
for (k in 2:length(comvar)){
f2 <- paste0(f2,"+",comvar[k])
}
}
oout2 <- lm(formula=f2,data=auxdat) ## regression without intercept because of "con" in "comvar"
Fopar <- matrix(oout2$coefficients,ncol=1)
# prediction in main data, not auxiliary data
ohat  <- as.matrix(maindat[,comvar])%*%Fopar
osd   <- sd(oout2$residuals,na.rm=TRUE)
#############
# compute bounds of E[(depvar)*(omitted variable)]
#############
ovar_m_l <- rep(NA,Nm)
ovar_m_u <- rep(NA,Nm)
for (k in 1:Nm){
ovar_m_u[k] <- qnorm(p=   pnorm(q=maindat[k,depvar],mean=yhat[k],sd=ysd) ,mean=ohat[k],sd=osd)
ovar_m_l[k] <- qnorm(p=(1-pnorm(q=maindat[k,depvar],mean=yhat[k],sd=ysd)),mean=ohat[k],sd=osd)
}
} else if (method==2){
comvar2 <- comvar[comvar!="con"]
# estimate f(depvar | comvar) nonparametrically
# bandwidth selection
bws1 <- npcdistbw(ydat=maindat[,depvar],xdat=maindat[,comvar2])
Fyz  <- npcdist(bws1)$condist ### Fyz$condist saves the predicted cdf values
bws2 <- npcdistbw(ydat=auxdat[,ovar],xdat=auxdat[,comvar2])
# compute matching function mu(depvar) = ovar| depvar, comvar
mu_y <- function(xx,ccdf,maximize){
if (maximize==1){
# find matching ovar to maximize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=ccdf,exdat=xx)$quantile
} else {
# find matching ovar to minimize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=(1-ccdf),exdat=xx)$quantile
}
return(ovar1)
}
ovar_m_l <- rep(NA,Nm)
ovar_m_u <- rep(NA,Nm)
for(i in 1:Nm){
eexdat <- data.frame(maindat[i,comvar2])
colnames(eexdat) <- comvar2 ### make the data frame similar to txdat
ovar_m_l[i]     <- mu_y(xx=eexdat,ccdf=Fyz[i],maximize=0)
ovar_m_u[i]     <- mu_y(xx=eexdat,ccdf=Fyz[i],maximize=1)
rm(eexdat)
}
} else {
stop("Method should be either 1 or 2.")
}
#############
# compute lower bound and upper bound
#############
mu_l <- mean(maindat[,depvar]*ovar_m_l,na.rm=TRUE)
mu_u <- mean(maindat[,depvar]*ovar_m_u,na.rm=TRUE)
hat_beta_l <- rep(NA,nr)
hat_beta_u <- rep(NA,nr)
# submatrices
A1 <- (t(as.matrix(auxdat[,ovar]))%*%as.matrix(auxdat[,ovar]))/Na
A2 <- (t(as.matrix(auxdat[,ovar]))%*%as.matrix(auxdat[,comvar]))/Na
C  <- as.matrix(rbind(maindat[,comvar],auxdat[,comvar]))
A3 <- (t(C)%*%C)/(Na+Nm)
XX <- as.matrix(rbind(cbind(A1,A2),cbind(t(A2),A3)))
# OLS formula
B <- (t(as.matrix(maindat[,depvar]))%*%as.matrix(maindat[,comvar]))/Nm
B_l <- matrix(c(mu_l,B),ncol=1)
B_u <- matrix(c(mu_u,B),ncol=1)
hat_beta_l <- matrix(pmin(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
hat_beta_u <- matrix(pmax(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
colnames(hat_beta_l) <- c(ovar,comvar)
colnames(hat_beta_u) <- c(ovar,comvar)
# change the order of OLS coefficients
comvar2 <- comvar[comvar!="con"]
hat_beta_l <- c(hat_beta_l[,"con"],hat_beta_l[,ovar],hat_beta_l[,comvar2])
hat_beta_u <- c(hat_beta_u[,"con"],hat_beta_u[,ovar],hat_beta_u[,comvar2])
return(list(hat_beta_l=hat_beta_l,hat_beta_u=hat_beta_u))
}
#### Monte Carlo simulation
Nm <- 3000
Na <- 3000
# same DGP in maindat and auxdat
library(MASS)
library(dplyr)
maindat <- mvrnorm(Nm,mu=c(2,3,1),Sigma=rbind(c(2,1,1),c(1,2,1),c(1,1,2)))
auxdat  <- mvrnorm(Na,mu=c(2,3,1),Sigma=rbind(c(2,1,1),c(1,2,1),c(1,1,2)))
maindat <- as.data.frame(maindat)
auxdat <- as.data.frame(auxdat)
colnames(maindat) <- c("x1","x2","x3")
colnames(auxdat) <- c("x1","x2","x3")
truebeta <- matrix(c(2,1,3,2),ncol=1)
maindat$y <- as.matrix(cbind(rep(1,Nm),maindat[,c("x1","x2","x3")]))%*%truebeta
# main data misses one omitted variable "x1"
maindat <- maindat[,c("x2","x3","y")]
oout <- bndovb(maindat=maindat,auxdat=auxdat,depvar="y",ovar="x1",comvar=c("x2","x3"),method=2)

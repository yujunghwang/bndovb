C  <- as.matrix(rbind(mw* maindat[,comvar], aw* auxdat[,comvar]))
IC <- as.matrix(rbind(mw*Imaindat[,comvar], aw*Iauxdat[,comvar]))
C2  <- as.matrix(rbind( maindat[,comvar],  auxdat[,comvar]))
IC2 <- as.matrix(rbind(Imaindat[,comvar], Iauxdat[,comvar]))
A3 <- (t(C)%*%C2)/(t(IC)%*%IC2)
}
XX <- as.matrix(rbind(cbind(A1,A2),cbind(t(A2),A3)))
# OLS formula
if (is.null(mainweights)){
B <- (t(as.matrix(maindat[,depvar]))%*%as.matrix(maindat[,comvar]))/(t(as.matrix(Imaindat[,depvar]))%*%as.matrix(Imaindat[,comvar]))
} else {
B <- (t(as.matrix(mainweights*maindat[,depvar]))%*%as.matrix(maindat[,comvar]))/(t(as.matrix(mainweights*Imaindat[,depvar]))%*%as.matrix(Imaindat[,comvar]))
}
B_l <- matrix(c(mu_l,B),ncol=1)
B_u <- matrix(c(mu_u,B),ncol=1)
hat_beta_l <- matrix(pmin(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
hat_beta_u <- matrix(pmax(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
colnames(hat_beta_l) <- c("ovar",comvar)
colnames(hat_beta_u) <- c("ovar",comvar)
if (!is.null(signres)){
if (signres=="pos" & (hat_beta_l[1]<0)){
# solve the inverse problem
M <- pinv(XX)
mu_zero <- -(M[1,2:nr]%*%matrix(B,ncol=1))/M[1,1]
if (M[1,1]<0){
mu_u <- mu_zero
mu_l <- min(mu_zero,mu_l)
} else{
mu_l <- mu_zero
mu_u <- max(mu_zero,mu_u)
}
B_l <- matrix(c(mu_l,B),ncol=1)
B_u <- matrix(c(mu_u,B),ncol=1)
hat_beta_l <- matrix(pmin(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
hat_beta_u <- matrix(pmax(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
colnames(hat_beta_l) <- c("ovar",comvar)
colnames(hat_beta_u) <- c("ovar",comvar)
}
if (signres=="neg" & (hat_beta_u[1]>0)){
# solve the inverse problem
M <- pinv(XX)
mu_zero <- -(M[1,2:nr]%*%matrix(B,ncol=1))/M[1,1]
if (M[1,1]<0){
mu_l <- mu_zero
mu_u <- max(mu_zero,mu_u)
} else{
mu_u <- mu_zero
mu_l <- min(mu_zero,mu_l)
}
B_l <- matrix(c(mu_l,B),ncol=1)
B_u <- matrix(c(mu_u,B),ncol=1)
hat_beta_l <- matrix(pmin(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
hat_beta_u <- matrix(pmax(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
colnames(hat_beta_l) <- c("ovar",comvar)
colnames(hat_beta_u) <- c("ovar",comvar)
}
}
# change the order of OLS coefficients
comvar2 <- comvar[comvar!="con"]
hat_beta_l <- c(hat_beta_l[,"con"],hat_beta_l[,"ovar"],hat_beta_l[,comvar2])
hat_beta_u <- c(hat_beta_u[,"con"],hat_beta_u[,"ovar"],hat_beta_u[,comvar2])
hat_beta_l
hat_beta_u
k
bndovbme(maindat=bmdata,auxdat=badata,depvar="lnwage",
pvar=c("afqt_1981","gpa_english9","gpa_math9"),ptype=1,
comvar=c("yrsch","poexp","poexp2"),
mainweights=bmdata$sampweight,
auxweights=badata$sampweight,normalize=TRUE,signres="pos")
bndovbme
getwd()
setwd("/Users/yujung/Dropbox/Document/GitHub/bndovb")
library(devtools)
devtools::install(dependencies=FALSE)
library(bndovb)
bndovbme
bndovbme(maindat=bmdata,auxdat=badata,depvar="lnwage",
pvar=c("afqt_1981","gpa_english9","gpa_math9"),ptype=1,
comvar=c("yrsch","poexp","poexp2"),
mainweights=bmdata$sampweight,
auxweights=badata$sampweight,normalize=TRUE,signres="pos")
k=19
print(paste0("Bootstrap : ",k))
bmdata <- as.data.frame(matrix(rep(NA,mnvar),ncol=mnvar))
badata <- as.data.frame(matrix(rep(NA,anvar),ncol=anvar))
colnames(bmdata) <- colnames(spsid)
colnames(badata) <- colnames(snlsy)
bmdata <- bmdata[FALSE,]
badata <- badata[FALSE,]
for (l in 1:mN){
temp    <- spsid[spsid$id==mdraw[l,k],1:mnvar]
temp$id <- l #### bootstrap id
bmdata  <- rbind(bmdata,temp)
}
for (l in 1:aN){
temp    <- snlsy[snlsy$caseid==adraw[l,k],1:anvar]
temp$caseid <- l #### bootstrap id
badata  <- rbind(badata,temp)
}
bndovbme(maindat=bmdata,auxdat=badata,depvar="lnwage",
pvar=c("afqt_1981","gpa_english9","gpa_math9"),ptype=1,
comvar=c("yrsch","poexp","poexp2"),
mainweights=bmdata$sampweight,
auxweights=badata$sampweight,normalize=TRUE,signres="pos")
maindat=bmdata;auxdat=badata;depvar="lnwage";
pvar=c("afqt_1981","gpa_english9","gpa_math9");ptype=1;
comvar=c("yrsch","poexp","poexp2");
mainweights=bmdata$sampweight;
auxweights=badata$sampweight;normalize=TRUE;signres="pos"
# load libraries
library(stats)
library(utils)
library(pracma)
library(factormodel)
library(nnet)
#############
# check if inputs are there in a correct form
#############
if (!is.data.frame(maindat)){
stop("please provide main data in a data frame format.")
}
if (!is.data.frame(auxdat)){
stop("please provide auxiliary data in a data frame format.")
}
# check if column names of auxiliary data exists
if (is.null(colnames(auxdat))){
stop("column names of auxiliary data do not exist.")
}
# check if column names of main data exists
if (is.null(colnames(maindat))){
stop("column names of main data do not exist.")
}
# check if auxiliary dataset includes every independent regressor
if ((sum(comvar%in%colnames(auxdat))<length(comvar)) | (sum(pvar%in%colnames(auxdat))<length(pvar)) ){
stop("auxiliary dataset does not contain every right-hand side regressor.")
}
# check if main dataset includes every independent regressor
if (sum(comvar%in%colnames(maindat))<length(comvar)){
stop("main dataset does not contain every common right-hand side regressor.")
}
# check if main dataset includes dependent variable
if (!(depvar%in%colnames(maindat))){
stop("main dataset does not include the dependent variable.")
}
# check if the proxy variable type is correctly specified
if (!(ptype%in%c(1,2))){
stop("Incorrect type was specified for proxy variables. ptype should be either 1 or 2.")
}
# check if there are enough proxy variables
if ((ptype==1) & (length(pvar)<2)){
stop("There are insufficient number of proxy variables. There must be at least 2 proxy variables when the omitted variable is continuous.")
}
if ((ptype==2) & (length(pvar)<3)){
stop("There are insufficient number of proxy variables. There must be at least 3 proxy variables when the omitted variable is discrete.")
}
if (!is.null(mainweights)){
# check if the weight vector has right length
if (length(mainweights)!=dim(maindat)[1]){
stop("The length of 'mainweights' is not equal to the number of rows of 'maindat'.")
}
# check if any weight vector includes NA or NaN or Inf
if (sum(is.na(mainweights))>0|sum(is.nan(mainweights))>0|sum(is.infinite(mainweights))>0){
stop("mainweights vector can not include any NAs or NaNs or Infs.")
}
}
if (!is.null(auxweights)){
# check if the weight variable is included in the auxdat
if (length(auxweights)!=dim(auxdat)[1]){
stop("The length of 'auxweights' is not equal to the number of rows of 'auxdat'.")
}
# check if any weight vector includes NA or NaN or Inf
if (sum(is.na(auxweights))>0|sum(is.nan(auxweights))>0|sum(is.infinite(auxweights))>0){
stop("auxweights vector can not include any NAs or NaNs or Infs.")
}
}
if (!is.null(signres)){
if (signres!="pos" & signres!="neg"){
stop("signres must be either NULL or pos or neg.")
}
}
#############
# prepare data in a right form
#############
# number of observations
Nm <- dim(maindat)[1]
Na <- dim(auxdat)[1]
# add 1 vector
comvar <- c(comvar,"con")
maindat$con <- rep(1,Nm)
auxdat$con <- rep(1,Na)
# leave only necessary variables and make the order of variables consistent
maindat <- maindat[,c(depvar,comvar)]
auxdat <- auxdat[,c(pvar,comvar)]
# add a weight vector to use 'lm' later
maindat$mainweights <- mainweights
auxdat$auxweights   <- auxweights
# number of regressors in a regrssion model (assuming there is only one omitted variable)
nr <- length(comvar)+1
#############
# estimate CDF and Quantile function
#############
# estimate N(depvar | comvar)
f1 <- paste0(depvar,"~ 0 +",comvar[1])
if (length(comvar)>1){
for (k in 2:length(comvar)){
f1 <- paste0(f1,"+",comvar[k])
}
}
if (is.null(mainweights)){
oout1 <- lm(formula=f1,data=maindat) ## regression without intercept because of "con" in "comvar"
} else{
oout1 <- lm(formula=f1,data=maindat,weights=mainweights) ## regression without intercept because of "con" in "comvar"
}
Fypar <- matrix(oout1$coefficients,ncol=1)
Fypar[is.na(Fypar)] <- 0
yhat  <- as.matrix(maindat[,comvar])%*%Fypar
ysd   <- sd(oout1$residuals,na.rm=TRUE)
# estimate f(pvar | ovar)
if (ptype==1){
# continuous proxy variables
if (is.null(auxweights)){
pout <- cproxyme(dat=auxdat[,pvar],anchor=1)
} else{
pout <- cproxyme(dat=auxdat[,pvar],anchor=1,weights=auxweights)
}
if (normalize==TRUE){
# noramlize proxy variables so that latent variable has mean 0 and std 1
for (g in 1:length(pvar)){
auxdat[,pvar[g]] <- (auxdat[,pvar[g]] - pout$mtheta)/(sqrt(pout$vartheta))
}
# reestimate measurement equations with normalized proxy variables
if (is.null(auxweights)){
pout <- cproxyme(dat=auxdat[,pvar],anchor=1)
} else{
pout <- cproxyme(dat=auxdat[,pvar],anchor=1,weights=auxweights)
}
}
alpha0   <- pout$alpha0
alpha1   <- pout$alpha1
varnu    <- pout$varnu
mtheta   <- pout$mtheta
vartheta <- pout$vartheta
} else if (ptype==2){
if (is.null(auxweights)){
pout <- dproxyme(dat=auxdat[,pvar],sbar,initvar=1)
} else{
pout <- dproxyme(dat=auxdat[,pvar],sbar,initvar=1,weights=auxweights)
}
M_param     <-pout$M_param
M_param_col <-pout$M_param_col
M_param_row <-pout$M_param_row
mparam      <-pout$mparam
typeprob    <-pout$typeprob
} else {
stop("ptype should be either 1 or 2.")
}
N <- dim(auxdat)[1]
nc <- length(comvar)
# estimate N(ovar | comvar)
if (ptype==1){
# construct normalized proxy variables
npdat  <- auxdat[,pvar]
np <- length(pvar)
nsdnu <- rep(NA,np)
for (i in 1:np){
npdat[,i] <- (npdat[,i]-alpha0[i])/alpha1[i]
nsdnu[i]  <- sqrt(varnu[i]/(alpha1[i]^2))
}
# stack up the normalized proxy data
sdat <- cbind(npdat[,1],auxdat[,comvar])
colnames(sdat) <- c("y",comvar)
for (a in 2:np){
sdat0 <- cbind(npdat[,a],auxdat[,comvar])
colnames(sdat0) <- c("y",comvar)
sdat <- rbind(sdat,sdat0)
}
sdat <- as.data.frame(sdat)
f2 <- paste0("y ~ 0 +",comvar[1])
if (length(comvar)>1){
for (k in 2:length(comvar)){
f2 <- paste0(f2,"+",comvar[k])
}
}
if (is.null(auxweights)){
oout2 <- lm(formula=f2,data=sdat) ## regression without intercept because of "con" in "comvar"
} else{
sdat$weights <- rep(auxweights,np)
oout2 <- lm(formula=f2,data=sdat,weights=weights) ## regression without intercept because of "con" in "comvar"
}
# prediction in main data, not auxiliary data
param <- oout2$coefficients
param[is.na(param)] <- 0
Fopar <- matrix(param[1:nc],ncol=1)
ohat  <- as.matrix(maindat[,comvar])%*%Fopar
varNoNA <- function(x) var(x,na.rm=TRUE)
res <- sdat[,"y"] - as.matrix(sdat[,comvar])%*%Fopar
osd <- mean(sqrt(apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2))
#############
# compute bounds of E[(depvar)*(omitted variable)]
#############
ovar_m_l <- rep(NA,Nm)
ovar_m_u <- rep(NA,Nm)
for (k in 1:Nm){
if (!is.na(maindat[k,depvar]) & !is.nan(maindat[k,depvar]) & !is.na(yhat[k]) & !is.nan(yhat[k]) & !is.na(ysd) & !is.nan(ysd) & !is.na(ohat[k]) & !is.nan(ohat[k]) & !is.na(osd) & !is.nan(osd) ){
ovar_m_u[k] <- qnorm(p=   pnorm(q=maindat[k,depvar],mean=yhat[k],sd=ysd) ,mean=ohat[k],sd=osd)
ovar_m_l[k] <- qnorm(p=(1-pnorm(q=maindat[k,depvar],mean=yhat[k],sd=ysd)),mean=ohat[k],sd=osd)
}
}
} else if (ptype==2){
if (is.null(auxweights)){
oout2 <- multinom(formula=typeprob~as.matrix(auxdat[,comvar[1:(nc-1)]]),maxit=10000,trace=FALSE) ## regression without intercept because of "con" in "comvar"
} else{
oout2 <- multinom(formula=typeprob~as.matrix(auxdat[,comvar[1:(nc-1)]]),weights=auxweights,maxit=10000,trace=FALSE) ## regression without intercept because of "con" in "comvar"
}
param <- t(coef(oout2))
param[is.na(param)]<-0
npr <- dim(param)[1]
npc <- dim(param)[2]
# move intercept to the last row
Fopar <- rbind(matrix(param[2:npr,],ncol=npc),matrix(param[1,],ncol=npc))
# prediction in main data, not auxiliary data
Fopar  <- cbind(rep(0,nc),Fopar)
oprob  <- exp(as.matrix(maindat[,comvar])%*%Fopar)
oprob  <- oprob/matrix(rep(apply(oprob,1,sum),sbar),ncol=sbar)
coprob <- t(apply(oprob,1,cumsum))
#############
# compute bounds of E[(depvar)*(omitted variable)]
#############
ovar_m_l <- rep(NA,Nm)
ovar_m_u <- rep(NA,Nm)
if (normalize==TRUE){
ogrid <- (c(1:sbar)-mean(c(1:sbar)))/sd(c(1:sbar))
} else{
ogrid <- c(1:sbar)
}
for (k in 1:Nm){
if (!is.na(maindat[k,depvar]) & !is.nan(maindat[k,depvar]) & !is.na(yhat[k]) & !is.nan(yhat[k]) & !is.na(ysd) & !is.nan(ysd) & sum(is.na(coprob[k,])|is.nan(coprob[k,]))==0 ){
ovar_m_u[k] <- ogrid[which(   pnorm(q=maindat[k,depvar],mean=yhat[k],sd=ysd) <coprob[k,])[1]]
ovar_m_l[k] <- ogrid[which((1-pnorm(q=maindat[k,depvar],mean=yhat[k],sd=ysd))<coprob[k,])[1]]
}
}
} else {
stop("ptype should be either 1 or 2.")
}
#############
# compute lower bound and upper bound
#############
osd
nsdnu
apply(matrix(res,ncol=np),2,varNoNA)
nsdnu^2
apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2
sqrt(0.01)
sqrt(0.001)
sqrt(apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2)
apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2
sqrt(0.01)
sqrt(0.001)
getwd()
k=20
print(paste0("Bootstrap : ",k))
bmdata <- as.data.frame(matrix(rep(NA,mnvar),ncol=mnvar))
badata <- as.data.frame(matrix(rep(NA,anvar),ncol=anvar))
colnames(bmdata) <- colnames(spsid)
colnames(badata) <- colnames(snlsy)
bmdata <- bmdata[FALSE,]
badata <- badata[FALSE,]
for (l in 1:mN){
temp    <- spsid[spsid$id==mdraw[l,k],1:mnvar]
temp$id <- l #### bootstrap id
bmdata  <- rbind(bmdata,temp)
}
for (l in 1:aN){
temp    <- snlsy[snlsy$caseid==adraw[l,k],1:anvar]
temp$caseid <- l #### bootstrap id
badata  <- rbind(badata,temp)
}
maindat=bmdata;auxdat=badata;depvar="lnwage";
pvar=c("afqt_1981","gpa_english9","gpa_math9");ptype=1;
comvar=c("yrsch","poexp","poexp2");
mainweights=bmdata$sampweight;
auxweights=badata$sampweight;normalize=TRUE;signres="pos"
#############
# prepare data in a right form
#############
# number of observations
Nm <- dim(maindat)[1]
Na <- dim(auxdat)[1]
# add 1 vector
comvar <- c(comvar,"con")
maindat$con <- rep(1,Nm)
auxdat$con <- rep(1,Na)
# leave only necessary variables and make the order of variables consistent
maindat <- maindat[,c(depvar,comvar)]
auxdat <- auxdat[,c(pvar,comvar)]
# add a weight vector to use 'lm' later
maindat$mainweights <- mainweights
auxdat$auxweights   <- auxweights
# number of regressors in a regrssion model (assuming there is only one omitted variable)
nr <- length(comvar)+1
#############
# estimate CDF and Quantile function
#############
# estimate N(depvar | comvar)
f1 <- paste0(depvar,"~ 0 +",comvar[1])
if (length(comvar)>1){
for (k in 2:length(comvar)){
f1 <- paste0(f1,"+",comvar[k])
}
}
if (is.null(mainweights)){
oout1 <- lm(formula=f1,data=maindat) ## regression without intercept because of "con" in "comvar"
} else{
oout1 <- lm(formula=f1,data=maindat,weights=mainweights) ## regression without intercept because of "con" in "comvar"
}
Fypar <- matrix(oout1$coefficients,ncol=1)
Fypar[is.na(Fypar)] <- 0
yhat  <- as.matrix(maindat[,comvar])%*%Fypar
ysd   <- sd(oout1$residuals,na.rm=TRUE)
# estimate f(pvar | ovar)
if (ptype==1){
# continuous proxy variables
if (is.null(auxweights)){
pout <- cproxyme(dat=auxdat[,pvar],anchor=1)
} else{
pout <- cproxyme(dat=auxdat[,pvar],anchor=1,weights=auxweights)
}
if (normalize==TRUE){
# noramlize proxy variables so that latent variable has mean 0 and std 1
for (g in 1:length(pvar)){
auxdat[,pvar[g]] <- (auxdat[,pvar[g]] - pout$mtheta)/(sqrt(pout$vartheta))
}
# reestimate measurement equations with normalized proxy variables
if (is.null(auxweights)){
pout <- cproxyme(dat=auxdat[,pvar],anchor=1)
} else{
pout <- cproxyme(dat=auxdat[,pvar],anchor=1,weights=auxweights)
}
}
alpha0   <- pout$alpha0
alpha1   <- pout$alpha1
varnu    <- pout$varnu
mtheta   <- pout$mtheta
vartheta <- pout$vartheta
} else if (ptype==2){
if (is.null(auxweights)){
pout <- dproxyme(dat=auxdat[,pvar],sbar,initvar=1)
} else{
pout <- dproxyme(dat=auxdat[,pvar],sbar,initvar=1,weights=auxweights)
}
M_param     <-pout$M_param
M_param_col <-pout$M_param_col
M_param_row <-pout$M_param_row
mparam      <-pout$mparam
typeprob    <-pout$typeprob
} else {
stop("ptype should be either 1 or 2.")
}
N <- dim(auxdat)[1]
nc <- length(comvar)
# construct normalized proxy variables
npdat  <- auxdat[,pvar]
np <- length(pvar)
nsdnu <- rep(NA,np)
for (i in 1:np){
npdat[,i] <- (npdat[,i]-alpha0[i])/alpha1[i]
nsdnu[i]  <- sqrt(varnu[i]/(alpha1[i]^2))
}
# stack up the normalized proxy data
sdat <- cbind(npdat[,1],auxdat[,comvar])
colnames(sdat) <- c("y",comvar)
for (a in 2:np){
sdat0 <- cbind(npdat[,a],auxdat[,comvar])
colnames(sdat0) <- c("y",comvar)
sdat <- rbind(sdat,sdat0)
}
sdat <- as.data.frame(sdat)
f2 <- paste0("y ~ 0 +",comvar[1])
if (length(comvar)>1){
for (k in 2:length(comvar)){
f2 <- paste0(f2,"+",comvar[k])
}
}
if (is.null(auxweights)){
oout2 <- lm(formula=f2,data=sdat) ## regression without intercept because of "con" in "comvar"
} else{
sdat$weights <- rep(auxweights,np)
oout2 <- lm(formula=f2,data=sdat,weights=weights) ## regression without intercept because of "con" in "comvar"
}
# prediction in main data, not auxiliary data
param <- oout2$coefficients
param[is.na(param)] <- 0
Fopar <- matrix(param[1:nc],ncol=1)
ohat  <- as.matrix(maindat[,comvar])%*%Fopar
varNoNA <- function(x) var(x,na.rm=TRUE)
res <- sdat[,"y"] - as.matrix(sdat[,comvar])%*%Fopar
osd <- mean(sqrt(pmax(apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2,0.001)))
osd
mean(sqrt(pmax(apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2,0.01)))
pmax(apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2,0.001)
pmax(apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2,0.01)
sqrt(pmax(apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2,0.001))
sqrt(pmax(apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2,0.01))
mean(sqrt(pmax(apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2,0.001)))
mean(sqrt(pmax(apply(matrix(res,ncol=np),2,varNoNA)-(nsdnu)^2,0.01)))
sqrt(0.01)
devtools::document()
devtools::check()
devtools :: build()
devtools :: install(dependencies=FALSE)
library(bndovb)
bndovbme

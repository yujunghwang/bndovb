install.packages("RStata")
### Parallelized version of After_Hwang_v3_MonteCarlo.R using multivariate regressors
### check whether increasing sample size gives converging estimates to population bounds
#install.packages("splines")
#install.packages("quantreg")
#install.packages("pracma")
#install.packages("cubature")
#install.packages("foreach")
#install.packages("doParallel")
#install.packages("cde")
#install.packages("np")
#install.packages("McSpatial")
#install.packages("MASS")
#install.packages("emdbook")
library(splines)   # Libraries
library(quantreg)
library(pracma)
library(cubature)
library(foreach)                                                                # Parallel Implementation of Boostrap Calculations
library(doParallel)
library(cde)
library(np)
library(McSpatial)
library(MASS)
library(emdbook)
samsize <- c(6000)
beta    <- c(0,1,1,1)
gamma   <- c(0,1,1)
mu      <- c(0,0,0,0)
sigma   <- eye(4)
# mu and sigma for vector (w1,w2,x,y)
A <- rbind( c(1,0,0,0), c(0,1,0,0), c(gamma[2],gamma[3],1,0), c(beta[3]+beta[2]*gamma[2],beta[4]+beta[2]*gamma[3], beta[2],1))
B <- c(0,0,gamma[1],beta[1])
mu2    <- A%*%mu + B
sigma2 <- A%*%sigma%*%t(A)
mu2
sigma2
A
gamma
beta
install.packages(c("broom", "ggthemes", "mapproj", "maps", "readstata13", "sf", "socviz", "tidycensus", "tidyverse", "tigris", "usmap"))
install.packages(c("broom", "ggthemes", "mapproj", "maps", "readstata13", "sf", "socviz", "tidycensus", "tidyverse", "tigris", "usmap"))
install.packages(c("broom", "ggthemes", "mapproj", "maps", "readstata13", "sf", "socviz", "tidycensus", "tidyverse", "tigris", "usmap"))
install.packages(c("broom", "ggthemes", "mapproj", "maps", "readstata13", "sf", "socviz", "tidycensus", "tidyverse", "tigris", "usmap"))
devtools::install_github("hrbrmstr/albersusa")
library(albersusa)
devtools::install_github("ropensci/USAboundariesData")
rm(list=ls()) # clean memory
#setwd("/Users/denghuan/Downloads/covid19")
library(tidyverse)
library(socviz) # to draw maps wihout discarding Alaska
library(maps)
library(mapproj)
library(tigris)
library(tidycensus)
library(sf)
library(broom)
library(viridis)
library(USAboundariesData)
library(usmap)
#devtools::install_github("hrbrmstr/albersusa")
#devtools::install_github("ropensci/USAboundariesData")
library(ggthemes)
library(albersusa)
library(copula)
cop <- gumbleCopula(200)
cop <- gumbelCopula(200)
contourplot2(cop,dCopula)
contourplot2(cop,pCopula)
cop <- gumbelCopula(1)
cop <- gumbelCopula(2)
contourplot2(cop,dCopula)
cop <- gumbelCopula(100)
contourplot2(cop,dCopula)
cop <- claytonCopula(2)
contourplot2(cop,dCopula)
cop <- frankCopula(2)
contourplot2(cop,dCopula)
cop <- gumbelCopula(100)
contourplot2(cop,dCopula)
cop <- gumbelCopula(500)
contourplot2(cop,dCopula)
cop <- gumbelCopula(200)
contourplot2(cop,dCopula)
load("~/Dropbox/Document/AntiAsian Racism/Data/Pilot Survey/data/DistParam.RData")
# load libraries
# install these packages if you haven't
library(gmailr)
library(googlesheets4)
### set a directory for a Gmail Client ID json file
FILEDIR="/Users/yujung/Dropbox/Document/GoogleAPI/"
### set a filename for the json file
FILENAME="gmailr.json"
# configure Gmail API
gm_auth_configure(path=paste0(FILEDIR,FILENAME))
### read seminar schedule info (CHANGE THE SPREADSHEET LINK BELOW)
seminar_schedule_link <- "https://docs.google.com/spreadsheets/d/1TVZpmKuRcB2IbOgfgtGQvebvVEMMS8LoNHuEvh30EU8/edit#gid=0"
seminar_schedule <- read_sheet(seminar_schedule_link)
# compute the days until the next seminar
daysleft <- as.Date(seminar_schedule$Date) - Sys.Date()
ind <- which(daysleft>=0)[1]
### retrieve the next speaker information
### seminar speaker name
speaker_name =seminar_schedule$Speaker[ind]
### speaker email
speaker_email =seminar_schedule$Email[ind]
### speaker institution
speaker_institution =seminar_schedule$Institution[ind]
### paper title
paper_title =seminar_schedule$Paper[ind]
### seminar date and time
seminar_date=seminar_schedule$Date[ind]
seminar_time=seminar_schedule$Time[ind]
### Set organizer / audience information
### Organizer first name
organizer_name="Yujung"
### Organizer email address
organizer_email ="yujungghwang@gmail.com"
### Audience email
audience_email ="yujungghwang@gmail.com"
### Zoom link for the seminar
zoom_link="https://zoom.us/my/yhwang"
### sign up information
signup_link ="https://docs.google.com/spreadsheets/d/11HCLZPHPx0j0ILhy3w8u5QAiPk1SD8paJdbgVzPJSm0/edit#gid=0"
grad_signup_time ="Monday 10AM"
# load libraries
# install these packages if you haven't
library(gmailr)
library(googlesheets4)
### set a directory for a Gmail Client ID json file
FILEDIR="/Users/yujung/Dropbox/Document/GoogleAPI/"
### set a filename for the json file
FILENAME="gmailr.json"
# configure Gmail API
gm_auth_configure(path=paste0(FILEDIR,FILENAME))
### read seminar schedule info (CHANGE THE SPREADSHEET LINK BELOW)
seminar_schedule_link <- "https://docs.google.com/spreadsheets/d/1TVZpmKuRcB2IbOgfgtGQvebvVEMMS8LoNHuEvh30EU8/edit#gid=0"
seminar_schedule <- read_sheet(seminar_schedule_link)
# compute the days until the next seminar
daysleft <- as.Date(seminar_schedule$Date) - Sys.Date()
ind <- which(daysleft>=0)[1]
### retrieve the next speaker information
### seminar speaker name
speaker_name =seminar_schedule$Speaker[ind]
### speaker email
speaker_email =seminar_schedule$Email[ind]
### speaker institution
speaker_institution =seminar_schedule$Institution[ind]
### paper title
paper_title =seminar_schedule$Paper[ind]
### seminar date and time
seminar_date=seminar_schedule$Date[ind]
seminar_time=seminar_schedule$Time[ind]
### Set organizer / audience information
### Organizer first name
organizer_name="Yujung"
### Organizer email address
organizer_email ="yujungghwang@gmail.com"
### Audience email
audience_email ="yujungghwang@gmail.com"
### Zoom link for the seminar
zoom_link="https://zoom.us/my/yhwang"
### sign up information
signup_link ="https://docs.google.com/spreadsheets/d/11HCLZPHPx0j0ILhy3w8u5QAiPk1SD8paJdbgVzPJSm0/edit#gid=0"
grad_signup_time ="Monday 10AM"
# email to a seminar speaker to ask a paper title / paper copy
# first check if there is any seminar scheduled within the next 10 days & if paper title is empty
source("setGmailConfig.R")
daysleft[ind]
seminar_schedule
is.null(seminar_schedule$PaperTitle[ind])
is.na(seminar_schedule$PaperTitle[ind])
help(range_clear)
# update the sign up sheet to blank page
range_clear(signup_link,range="B3:B12")
range_clear(signup_link,range="A1")
range_write(signup_link,data=paste0(speaker_name," sign up"),range="A1")
speaker_name
range_write(signup_link,data=as.data.frame(paste0(speaker_name," sign up")),range="A1")
range_write(signup_link,data=as.data.frame(x=paste0(speaker_name," sign up")),range="A1")
as.data.frame(paste0(speaker_name," sign up"))
range_write(signup_link,data=as.data.frame(paste0(speaker_name," sign up"))[1,1],range="A1")
as.data.frame(paste0(speaker_name," sign up"))
signuphead=as.data.frame(paste0(speaker_name," sign up"))
colnames(signuphead)=NULL
signuphead
range_write(signup_link,data=signuphead,range="A1")
seminar_date
signuphead=as.data.frame(a1=paste0(speaker_name," sign up"),a2=paste0("Date : ",seminar_date))
colnames(signuphead)=NULL
range_write(signup_link,data=signuphead,range="A1")
signuphead=as.data.frame(x=paste0(speaker_name," sign up"),y=paste0("Date : ",seminar_date))
signuphead
signuphead=as.data.frame(cbind(paste0(speaker_name," sign up"),paste0("Date : ",seminar_date)))
signuphead
colnames(signuphead)=NULL
range_write(signup_link,data=signuphead,range="A1")
Sys.time()
format(Sys.time())
Sys.getenv("R_HOME")
library(factormodel)
setwd("/Users/yujung/Dropbox/Document/GitHub/bndovb")
devtools::check()
devtools::build()
devtools::install(dependencies = FALSE)
library(bndovb)
bndovb
bndovb(maindat=maindat_nome,auxdat=auxdat_nome,depvar="y",ovar="x1",comvar=c("x2","x3"),method=1)
bndovb(maindat=maindat_nome,auxdat=auxdat_nome,depvar="y",ovar="x1",comvar=c("x2","x3"),method=1,mainweights=NULL,auxweights=NULL)
bndovb
devtools::document()
devtools::check()
devtools::build()
devtools::install(dependencies=FALSE)
library(bndovb)
data(maindat_nome)
data(auxdat_nome)
bndovb(maindat=maindat_nome,auxdat=auxdat_nome,depvar="y",ovar="x1",comvar=c("x2","x3"),method=1)
bndovb
bndovb(maindat=maindat_nome,auxdat=auxdat_nome,depvar="y",ovar="x1",comvar=c("x2","x3"),method=1,mainweights=NULL,auxweights=NULL)
maindat=maindat_nome;auxdat=auxdat_nome;depvar="y";ovar="x1";comvar=c("x2","x3");method=1;mainweights=NULL;auxweights=NULL
if (!is.matrix(maindat) & !is.data.frame(maindat)){
stop("please provide main data in either matrix or data frame format.")
}
if (!is.matrix(auxdat) & !is.data.frame(auxdat)){
stop("please provide auxiliary data in either matrix or data frame format.")
}
# check if column names of auxiliary data exists
if (is.null(colnames(auxdat))){
stop("column names of auxiliary data do not exist.")
}
# check if column names of main data exists
if (is.null(colnames(maindat))){
stop("column names of main data do not exist.")
}
if (length(ovar)>1){
stop("there are too many omitted variables.")
}
# check if auxiliary dataset includes every independent regressor
if ((sum(comvar%in%colnames(auxdat))<length(comvar)) | !(ovar%in%colnames(auxdat)) ){
stop("auxiliary dataset does not contain every right-hand side regressor.")
}
# check if main dataset includes every independent regressor
if (sum(comvar%in%colnames(maindat))<length(comvar)){
stop("main dataset does not contain every common right-hand side regressor.")
}
# check if main dataset includes dependent variable
if (!(depvar%in%colnames(maindat))){
stop("main dataset does not include the dependent variable.")
}
# check if method is specified correctly
if (!(method%in%c(1,2))){
stop("Incorrect method was specified. Method should be either 1 or 2.")
}
if (!is.null(mainweights)){
# check if the weight vector for main data has a correct length
if (length(mainweights)!=dim(maindat)[1]){
stop("Incorrect length for the main data weight vector. The length must be equal to the number of rows of 'maindat'.")
}
# check if any weight vector includes NA or NaN or Inf
if (sum(is.na(mainweights))>0|sum(is.nan(mainweights))>0|sum(is.infinite(mainweights))>0){
stop("mainweights vector can not include any NAs or NaNs or Infs.")
}
}
if (!is.null(auxweights)){
# check if the weight vector for auxiliary data has a correct length
if (length(auxweights)!=dim(auxdat)[1]){
stop("Incorrect length for the auxiliary data weight vector. The length must be equal to the number of rows of 'auxdat'.")
}
# check if any weight vector includes NA or NaN or Inf
if (sum(is.na(auxweights))>0|sum(is.nan(auxweights))>0|sum(is.infinite(auxweights))>0){
stop("auxweights vector can not include any NAs or NaNs or Infs.")
}
}
#############
#############
# prepare data in a right form
#############
# number of observations
Nm <- dim(maindat)[1]
Na <- dim(auxdat)[1]
# add 1 vector
comvar <- c(comvar,"con")
maindat$con <- rep(1,Nm)
auxdat$con <- rep(1,Na)
# leave only necessary variables and make the order of variables consistent
maindat <- maindat[,c(depvar,comvar)]
auxdat <- auxdat[,c(ovar,comvar)]
# number of regressors in a regrssion model
nr <- length(comvar)+length(ovar)
#############
# estimate CDF and Quantile function
#############
if (method==1){
# estimate N(depvar | comvar)
f1 <- paste0(depvar,"~ 0 +",comvar[1])
if (length(comvar)>1){
for (k in 2:length(comvar)){
f1 <- paste0(f1,"+",comvar[k])
}
}
if (is.null(mainweights)){
oout1 <- lm(formula=f1,data=maindat) ## regression without intercept because of "con" in "comvar"
} else{
oout1 <- lm(formula=f1,data=maindat,weights=mainweights) ## regression without intercept because of "con" in "comvar"
}
Fypar <- matrix(oout1$coefficients,ncol=1)
yhat  <- as.matrix(maindat[,comvar])%*%Fypar
ysd   <- sd(oout1$residuals,na.rm=TRUE)
# estimate N(ovar | comvar)
f2 <- paste0(ovar,"~ 0 +",comvar[1])
if (length(comvar)>1){
for (k in 2:length(comvar)){
f2 <- paste0(f2,"+",comvar[k])
}
}
if (is.null(auxweights)){
oout2 <- lm(formula=f2,data=auxdat) ## regression without intercept because of "con" in "comvar"
} else{
oout2 <- lm(formula=f2,data=auxdat,weights=auxweights) ## regression without intercept because of "con" in "comvar"
}
Fopar <- matrix(oout2$coefficients,ncol=1)
# prediction in main data, not auxiliary data
ohat  <- as.matrix(maindat[,comvar])%*%Fopar
osd   <- sd(oout2$residuals,na.rm=TRUE)
#############
# compute bounds of E[(depvar)*(omitted variable)]
#############
ovar_m_l <- rep(NA,Nm)
ovar_m_u <- rep(NA,Nm)
for (k in 1:Nm){
if (!is.na(maindat[k,depvar]) & !is.nan(maindat[k,depvar]) & !is.na(yhat[k]) & !is.nan(yhat[k]) & !is.na(ysd) & !is.nan(ysd) & !is.na(ohat[k]) & !is.nan(ohat[k]) & !is.na(osd) & !is.nan(osd) ){
ovar_m_u[k] <- qnorm(p=   pnorm(q=maindat[k,depvar],mean=yhat[k],sd=ysd) ,mean=ohat[k],sd=osd)
ovar_m_l[k] <- qnorm(p=(1-pnorm(q=maindat[k,depvar],mean=yhat[k],sd=ysd)),mean=ohat[k],sd=osd)
}
}
} else if (method==2){
### use np package
# estimate f(depvar | comvar) nonparametrically
# bandwidth selection
bws1 <- npcdistbw(ydat=maindat[,depvar],xdat=maindat[,comvar])
Fyz  <- npcdist(bws1)$condist ### Fyz$condist saves the predicted cdf values
bws2 <- npcdistbw(ydat=auxdat[,ovar],xdat=auxdat[,comvar])
# compute matching function mu(depvar) = ovar| depvar, comvar
mu_y <- function(xx,ccdf,maximize){
if (maximize==1){
# find matching ovar to maximize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=ccdf,exdat=xx)$quantile
} else {
# find matching ovar to minimize E[depvar * ovar]
ovar1  <- npqreg(bws2,tau=(1-ccdf),exdat=xx)$quantile
}
return(ovar1)
}
ovar_m_l <- rep(NA,Nm)
ovar_m_u <- rep(NA,Nm)
for(i in 1:Nm){
eexdat <- data.frame(maindat[i,comvar])
colnames(eexdat) <- c(1:length(comvar)) ### make the data frame similar to txdat
ovar_m_l[i]     <- mu_y(eexdat,ccdf=Fyz[i],maximize=0)
ovar_m_u[i]     <- mu_y(eexdat,ccdf=Fyz[i],maximize=1)
rm(eexdat)
}
} else {
stop("Method should be either 1 or 2.")
}
#############
# compute lower bound and upper bound
#############
# replace missing values to 0 and create a dummy for missingness
Imaindat <- !is.na(maindat)
Iauxdat  <- !is.na(auxdat)
colnames(Imaindat) <- colnames(maindat)
colnames(Iauxdat)  <- colnames(auxdat)
maindat[!Imaindat] <-0
auxdat[!Iauxdat]   <-0
Iovar_m_l <- !is.na(ovar_m_l)
Iovar_m_u <- !is.na(ovar_m_u)
ovar_m_l[!Iovar_m_l] <-0
ovar_m_u[!Iovar_m_u] <-0
hat_beta_l <- rep(NA,nr)
hat_beta_u <- rep(NA,nr)
if (is.null(mainweights)){
mu_l <- sum(maindat[,depvar]*ovar_m_l) / sum(Imaindat[,depvar]*Iovar_m_l)
mu_u <- sum(maindat[,depvar]*ovar_m_u) / sum(Imaindat[,depvar]*Iovar_m_u)
} else{
mu_l <- sum(maindat[,depvar]*ovar_m_l*mainweights) / sum(Imaindat[,depvar]*Iovar_m_l*mainweights)
mu_u <- sum(maindat[,depvar]*ovar_m_u*mainweights) / sum(Imaindat[,depvar]*Iovar_m_u*mainweights)
}
# submatrices
if (is.null(auxweights)){
A1 <- (t(as.matrix(auxdat[,ovar]))%*%as.matrix(auxdat[,ovar]))  /(t(as.matrix(Iauxdat[,ovar]))%*%as.matrix(Iauxdat[,ovar]))
A2 <- (t(as.matrix(auxdat[,ovar]))%*%as.matrix(auxdat[,comvar]))/(t(as.matrix(Iauxdat[,ovar]))%*%as.matrix(Iauxdat[,comvar]))
} else{
A1 <- (t(as.matrix(auxweights*auxdat[,ovar]))%*%as.matrix(auxdat[,ovar]))  /sum(t(as.matrix(auxweights*Iauxdat[,ovar]))%*%as.matrix(Iauxdat[,ovar]))
A2 <- (t(as.matrix(auxweights*auxdat[,ovar]))%*%as.matrix(auxdat[,comvar]))/sum(t(as.matrix(auxweights*Iauxdat[,ovar]))%*%as.matrix(Iauxdat[,comvar]))
}
if (is.null(auxweights) & is.null(mainweights)){
C  <- as.matrix(rbind( maindat[,comvar], auxdat[,comvar]))
IC <- as.matrix(rbind(Imaindat[,comvar],Iauxdat[,comvar]))
A3 <- (t(C)%*%C)/(t(IC)%*%IC)
} else if(!is.null(auxweights) & is.null(mainweights)){
aw <- matrix(rep(auxweights, length(comvar)),ncol=length(comvar)) *(1/sum(auxweights)) * Na
C  <- as.matrix(rbind( maindat[,comvar],aw* auxdat[,comvar]))
IC <- as.matrix(rbind(Imaindat[,comvar],aw*Iauxdat[,comvar]))
A3 <- (t(C)%*%C)/(t(IC)%*%IC)
} else if(is.null(auxweights) & !is.null(mainweights)){
mw <- matrix(rep(mainweights,length(comvar)),ncol=length(comvar)) *(1/sum(mainweights)) * Nm
C  <- as.matrix(rbind(mw* maindat[,comvar],  auxdat[,comvar]))
IC <- as.matrix(rbind(mw*Imaindat[,comvar], Iauxdat[,comvar]))
A3 <- (t(C)%*%C)/(t(IC)%*%IC)
} else{
mw <- matrix(rep(mainweights,length(comvar)),ncol=length(comvar)) *(1/sum(mainweights)) * Nm
aw <- matrix(rep(auxweights, length(comvar)),ncol=length(comvar)) *(1/sum(auxweights))  * Na
C  <- as.matrix(rbind(mw* maindat[,comvar], aw* auxdat[,comvar]))
IC <- as.matrix(rbind(mw*Imaindat[,comvar], aw*Iauxdat[,comvar]))
A3 <- (t(C)%*%C)/(t(IC)%*%IC)
}
XX <- as.matrix(rbind(cbind(A1,A2),cbind(t(A2),A3)))
# OLS formula
if (is.null(mainweights)){
B <- (t(as.matrix(maindat[,depvar]))%*%as.matrix(maindat[,comvar]))/(t(as.matrix(Imaindat[,depvar]))%*%as.matrix(Imaindat[,comvar]))
} else{
B <- (t(as.matrix(mainweights*maindat[,depvar]))%*%as.matrix(maindat[,comvar]))/(t(as.matrix(mainweights*Imaindat[,depvar]))%*%as.matrix(Imaindat[,comvar]))
}
B_l <- matrix(c(mu_l,B),ncol=1)
B_u <- matrix(c(mu_u,B),ncol=1)
hat_beta_l <- matrix(pmin(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
hat_beta_u <- matrix(pmax(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
colnames(hat_beta_l) <- c(ovar,comvar)
colnames(hat_beta_u) <- c(ovar,comvar)
# change the order of OLS coefficients
comvar2 <- comvar[comvar!="con"]
hat_beta_l <- c(hat_beta_l[,"con"],hat_beta_l[,ovar],hat_beta_l[,comvar2])
hat_beta_u <- c(hat_beta_u[,"con"],hat_beta_u[,ovar],hat_beta_u[,comvar2])
library(pracma)
hat_beta_l <- matrix(pmin(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
hat_beta_u <- matrix(pmax(pinv(XX)%*%B_l,pinv(XX)%*%B_u),nrow=1)
colnames(hat_beta_l) <- c(ovar,comvar)
colnames(hat_beta_u) <- c(ovar,comvar)
# change the order of OLS coefficients
comvar2 <- comvar[comvar!="con"]
hat_beta_l <- c(hat_beta_l[,"con"],hat_beta_l[,ovar],hat_beta_l[,comvar2])
hat_beta_u <- c(hat_beta_u[,"con"],hat_beta_u[,ovar],hat_beta_u[,comvar2])
hat_beta_l
hat_beta_u
bndovb(maindat=maindat_nome,auxdat=auxdat_nome,depvar="y",ovar="x1",comvar=c("x2","x3"),method=1,mainweights=NULL,auxweights=NULL)
